import { generateCypherQuery, generateEmbeddings } from './llmService'; // generateEmbeddings added
import { executeQuery as executeNeo4jQuery, QueryResult } from './neo4jService';
import { searchSimilarChunks as searchChroma } from './vectorDbService'; // getOrCreateCollection not strictly needed here if searchChroma ensures it
import { CHROMA_COLLECTION_NAME } from '../config'; // Add this

interface FormattedGraphResult {
  // Define a structure for simpler result representation if needed
  // For now, we can return an array of records or a string summary
  records: any[];
  summary?: string; // Optional summary string
}

function formatNeo4jResults(neo4jResult: QueryResult): string[] {
  if (!neo4jResult || !neo4jResult.records || neo4jResult.records.length === 0) {
    return ['No results found in the graph.'];
  }
  // This is a basic formatter. It can be made more sophisticated.
  // It tries to convert records into readable strings.
  return neo4jResult.records.map(record => {
    let recordString = '';
    record.keys.forEach(key => {
      const value = record.get(key);
      let valueString = '';
      if (value && typeof value === 'object') {
        // Handle nodes or relationships or paths
        if (value.labels && value.properties) { // Likely a Node
          valueString = `Node(labels: ${value.labels.join(', ')}, properties: ${JSON.stringify(value.properties)})`;
        } else if (value.type && value.properties && value.start && value.end) { // Likely a Relationship
          valueString = `Relationship(type: ${value.type}, properties: ${JSON.stringify(value.properties)})`;
        } else {
          valueString = JSON.stringify(value); // Default object stringification
        }
      } else {
        valueString = String(value);
      }
      recordString += `${key}: ${valueString}; `;
    });
    return recordString.trim();
  }).slice(0, 10); // Limit to first 10 results for context brevity
}

export async function executeQueryAgainstGraph(naturalLanguageQuestion: string): Promise<string[]> {
  console.log(`Executing graph query for question: "${naturalLanguageQuestion}"`);
  // Define a simple schema description for the LLM. This can be expanded.
  const graphSchemaDescription =
    "Nodes are labeled ':Entity' and have a 'name' property. " +
    "Relationships are of type ':RELATIONSHIP' and have a 'type' property which stores the actual relation name (e.g., 'founded', 'launched'). " +
    "Example Cypher: MATCH (e1:Entity {name: 'SpaceX'})-[r:RELATIONSHIP {type: 'launched'}]->(e2:Entity {name: 'Falcon 9'}) RETURN e1, r, e2.";

  try {
    const cypherQuery = await generateCypherQuery(naturalLanguageQuestion, graphSchemaDescription);
    console.log(`Generated Cypher for graph query: ${cypherQuery}`);

    if (cypherQuery.includes('// Error:') || cypherQuery.includes('// Placeholder:')) {
      console.warn('Cannot execute placeholder or error Cypher query against graph.');
      return [`Could not translate question to a graph query effectively. Query generated: ${cypherQuery}`];
    }

    const neo4jResult = await executeNeo4jQuery(cypherQuery);
    console.log(`Successfully executed Cypher query. Records count: ${neo4jResult.records.length}`);

    return formatNeo4jResults(neo4jResult);

  } catch (error: any) {
    console.error('Error during graph query execution pipeline:', error.message);
    // Check if it's a Neo4jError and provide specific feedback
    if (error.code && error.code.startsWith('Neo.')) { // Neo4jError often has a code like Neo.ClientError.Statement.SyntaxError
        return [`Error executing graph query: ${error.message}. Potentially invalid Cypher generated by LLM.`];
    }
    return [`An error occurred while querying the knowledge graph: ${error.message}`];
  }
}

export async function searchVectorStore(
  naturalLanguageQuestion: string,
  collectionName: string = CHROMA_COLLECTION_NAME,
  topK: number = 3
): Promise<string[]> {
  console.log(`Executing vector store search for question: "${naturalLanguageQuestion}" in collection '${collectionName}'`);

  try {
    const questionEmbeddingResult = await generateEmbeddings([naturalLanguageQuestion]);
    if (!questionEmbeddingResult || questionEmbeddingResult.length === 0 || !questionEmbeddingResult[0] || questionEmbeddingResult[0].every(v => v === 0)) {
      console.warn('Failed to generate valid embedding for the question. Vector search might be ineffective or use mock data.');
      if (questionEmbeddingResult[0]?.every(v => v === 0)) {
         return ['Could not generate a valid question embedding for vector search (possibly missing API key for embeddings).'];
      }
      // If embeddings are just empty for some other reason, proceed but expect possibly no results.
    }

    // queryEmbeddings expects number[][]
    const questionEmbedding: number[][] = questionEmbeddingResult[0] ? [questionEmbeddingResult[0]] : [];

    if (questionEmbedding.length === 0) {
        // This case might already be covered by the check above, but as a safeguard:
        return ['Failed to generate embedding for vector search.'];
    }

    const similarChunksResults = await searchChroma(collectionName, questionEmbedding, topK);
    // searchChroma for a single query embedding ([questionEmbedding]) returns string[][] where outer array has 1 element
    console.log(`Found ${similarChunksResults.length > 0 ? similarChunksResults[0].length : 0} similar chunks from vector store for the question.`);

    const formattedChunks: string[] = (similarChunksResults && similarChunksResults.length > 0) ? similarChunksResults[0] : [];

    return formattedChunks;

  } catch (error: any) {
    console.error('Error during vector store search pipeline:', error.message);
    return [`An error occurred while searching the vector store: ${error.message}`];
  }
}
